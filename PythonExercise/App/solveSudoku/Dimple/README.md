#> 解数独的问题，放开让Python来做吧

在我心中，一直有一个成为数学家的梦，奈何数学总是不过关，学生时代经常因为低级的数学问题而冲不上一个好名次，命苦呀。

之前看了《最强大脑》的数独比赛，看着优秀的选手利用自己的**最强大脑**来解开一道道复杂的数独问题，心中又痒痒。周末闲来无事，就尝试下用Python来搞定这个走向数学的成才之路。

#### 什么是数独

数独是源自18世纪瑞士的一种数学游戏。是一种运用纸、笔进行演算的逻辑游戏。玩家需要根据9×9盘面上的已知数字，推理出所有剩余空格的数字，并满足每一行、每一列、每一个粗线宫（3*3）内的数字均含1-9，不重复。

数独盘面是个九宫，每一宫又分为九个小格。在这八十一格中给出一定的已知数字和解题条件，利用逻辑和推理，在其他的空格上填入1-9的数字。使1-9每个数字在每一行、每一列和每一宫中都只出现一次，所以又称“九宫格”。

#### 组成元素

1. 方格

水平方向有九横行，垂直方向有九纵列的矩形，画分八十一个小正方形，称为九宫格（Grid）。

2. 行

水平方向的每一横行有九格，每一横行称为行（Row）。

3. 列

垂直方向的每一纵列有九格，每一纵列称为列（Column）。

4. 宫

三行与三列相交之处有九格，每一单元称为小九宫（Box、Block），简称宫。

5. 组成

上述行、列、宫、单元格统称为单元（Unit）；而行、列、宫统称为区域（Region）。

#### 如何解题

我们这里采用直接搜索的方式，写一个辅助函数检查三条规则：

- 行上有没有冲突的元素
- 列上有没有冲突的元素
- 九宫格上有没有冲突的元素

如下所示：

```Python
# 判断当前位置是否有数字存在
def isvalid(board_value, i, j, num):
    # 先判断行，列固定不变,查看是否有冲突
    for row in range(0, 9):
        if board_value[row][j] != ".":
            d = int(board_value[row][j])
            if (d == num) is True:
                return False

    # 再判断列，行固定不变，查看是否有冲突
    for col in range(0, 9):
        if board_value[i][col] != ".":
            d = int(board_value[i][col])
            if (d == num) is True:
                return False

    # 9宫格是否有冲突
    for row in range(i // 3 * 3, i // 3 * 3 + 3):
        for col in range(j // 3 * 3, j // 3 * 3 + 3):

            if board_value[row][col] != ".":
                d = int(board_value[row][col])
                if (d == num) is True:
                    return False

    return True
```

因为是一个九宫格，我们传入的是一个二维数组，一行里面包含9个位置，总共是9行，组成的81个位置。

所以，还需要通过位置依次来填充。从（0，0）到（8，8），如果是"."，说明该位置没有被填充，则可以查找数字并填充进去，否则继续查找下一个位置。

如果填充失败，那么我们需要回溯。将原来尝试填充的地方改回来。

递归直到数独被填充完成。

具体如下：

```Python
# 查找函数
def search(board_value):
    # 总共有多少个数组
    for i in range(len(board_value)):
        # 循环每个数组
        for j in range(len(board_value[0])):
            # 如果不是空位（即"."），则继续寻找下一个位置
            if board_value[i][j] != ".":
                continue

            # 从数字1-9中依次去尝试
            for num in range(1, 10):
                result = isvalid(board_value, i, j, num)
                if result is False:
                    continue

                # 把数字填充到相应的位置
                board_value[i][j] = num
                # 继续寻找下一个位置
                result = search(board_value)

                # 如果全部执行完，都是正确，则已经完成搜索
                if result is True:
                    return True
                else:
                    # 回退之前的状态,本轮搜索失败,回退的时候也是递归的
                    board_value[i][j] = "."
            else:
                return False

    return True
```

#### 验证结果

解数独的核心就是这两个过程，当过程做完，接下来的事情，自然就需要我们去严谨的验证下，毕竟这无论是在数学界还是程序界，都是很有必要的过程。

输入一个二维数组，其中"."表示空格

```Python
s.solveSudoku([["5", "3", ".", ".", "7", ".", ".", ".", "."],
               ["6", ".", ".", "1", "9", "5", ".", ".", "."],
               [".", "9", "8", ".", ".", ".", ".", "6", "."],
               ["8", ".", ".", ".", "6", ".", ".", ".", "3"],
               ["4", ".", ".", "8", ".", "3", ".", ".", "1"],
               ["7", ".", ".", ".", "2", ".", ".", ".", "6"],
               [".", "6", ".", ".", ".", ".", "2", "8", "."],
               [".", ".", ".", "4", "1", "9", ".", ".", "5"],
               [".", ".", ".", ".", "8", ".", ".", "7", "9"]])
```

输出结果：

```Python
[['5', '3', 4, 6, '7', 8, 9, 1, 2],
['6', 7, 2, '1', '9', '5', 3, 4, 8], 
[1, '9', '8', 3, 4, 2, 5, '6', 7], 
['8', 5, 9, 7, '6', 1, 4, 2, '3'], 
['4', 2, 6, '8', 5, '3', 7, 9, '1'], 
['7', 1, 3, 9, '2', 4, 8, 5, '6'], 
[9, '6', 1, 5, 3, 7, '2', '8', 4], 
[2, 8, 7, '4', '1', '9', 6, 3, '5'], 
[3, 4, 5, 2, '8', 6, 1, '7', '9']]
```

惊喜吧，数独很正确的解答出来了。Python真的不是吹的，现在如果再次回去看《最强大脑》上的题目，你用Python把数组列输进去，结果自然就出来了。

数独这个问题就能很好的解决了，写程序的过程，也是一个深度思考的过程，很能提升我自己的数学能力，感谢Python给了我这个宝贵的机会，让我再次对数学进行了挑战。玩数独的，不服来战吧。